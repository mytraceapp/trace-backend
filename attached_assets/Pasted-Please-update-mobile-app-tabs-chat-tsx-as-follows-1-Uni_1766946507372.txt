Please update mobile/app/(tabs)/chat.tsx as follows:
	1.	Unify the message type

At the top of the file (near other types / interfaces), add:
type ChatRole = 'user' | 'assistant';

interface ChatMessage {
  id: string;
  role: ChatRole;
  content: string;
}

If there is already a message type/interface, update it so it matches this exactly (no extra text or message fields; just id, role, content).

Then, make sure the messages state is typed as this:
const [messages, setMessages] = useState<ChatMessage[]>([]);
Remove any other message arrays that duplicate this (e.g., chatMessages, historyMessages, etc.) and keep just messages.

‚∏ª

	2.	Make fetchChatHistory hydrate with { role, content }

Find the fetchChatHistory function you recently added (the one logging:
console.log('üï∞ TRACE loading chat history...');
console.log('üì• TRACE raw chat history payload:', JSON.stringify(json));
console.log('‚úÖ TRACE chat history loaded, hydrating messages:', json.messages?.length || 0);
Inside it, after you get json, replace the mapping logic with this:
if (json?.ok && Array.isArray(json.messages)) {
  const historyMessages: ChatMessage[] = json.messages.map(
    (m: { role: string; content: string }, index: number) => ({
      id: `history-${index}`,
      role: (m.role === 'assistant' ? 'assistant' : 'user') as ChatRole,
      content: m.content ?? '',
    })
  );

  console.log(
    'üí¨ TRACE mapped history messages sample:',
    historyMessages[0] || null
  );

  setMessages((current) =>
    current.length === 0 ? historyMessages : current
  );
} else {
  console.warn('‚ö†Ô∏è TRACE chat history: invalid payload', json);
}

Keep the existing logs around raw chat history and hydrating messages, just adjust the mapping to use ChatMessage and content.

‚∏ª

	3.	Make sure send handler uses the same shape & updates UI

Find your handleSend function (the one that calls sendChatMessage). Replace its internals with this logic (keep your prop names / options, just follow this pattern):
const handleSend = async () => {
  const trimmed = inputText.trim();
  if (!trimmed) return;

  // 1) Optimistically add the user message to state
  const userMessage: ChatMessage = {
    id: `local-user-${Date.now()}`,
    role: 'user',
    content: trimmed,
  };

  setMessages((prev) => [...prev, userMessage]);
  setInputText('');
  setIsSending(true);

  try {
    // Build a minimal messages payload for the API
    const payloadMessages = [...messages, userMessage].map((m) => ({
      role: m.role,
      content: m.content,
    }));

    const result = await sendChatMessage({
      messages: payloadMessages,
      userName,
      chatStyle,
      localTime,
      localDay,
      localDate,
      userId: authUserId ?? null,
      deviceId: stableId ?? null,
    });

    const assistantText: string =
      result?.message ||
      "I'm here with you. Something went wrong on my end, but you can still tell me what's on your mind.";

    const assistantMessage: ChatMessage = {
      id: `local-assistant-${Date.now()}`,
      role: 'assistant',
      content: assistantText,
    };

    // 2) Append TRACE reply to state
    setMessages((prev) => [...prev, assistantMessage]);
  } catch (err) {
    console.error('‚ùå TRACE handleSend error:', err);
  } finally {
    setIsSending(false);
  }
};

Key points:
	‚Ä¢	We always append the user bubble locally.
	‚Ä¢	When the API returns, we append one assistant bubble.
	‚Ä¢	We never overwrite messages with a brand-new array except in fetchChatHistory.

‚∏ª

	4.	Fix the render to use message.content

Find the part of the JSX that renders the chat messages. It might be a FlatList, ScrollView, or a custom list. It will look something like:

<FlatList
  data={messages}
  renderItem={({ item }) => (
    <ChatBubble
      // ...
      text={item.text}
    />
  )}
/>

Update it so:
	‚Ä¢	It uses item.content instead of item.text or item.message.
	‚Ä¢	It uses item.role to decide styling.

For example:

<FlatList
  data={messages}
  keyExtractor={(item) => item.id}
  renderItem={({ item }) => (
    <ChatBubble
      role={item.role}              // or isUser={item.role === 'user'}
      text={item.content}
    />
  )}
/>

If you‚Äôre not using a ChatBubble component, just make sure everywhere you show message text you read from message.content.

Also, right above the list, add a render debug log so we can confirm:
console.log('üß© TRACE chat render, messages length:', messages.length);
if (messages[0]) {
  console.log('üß© TRACE first message sample:', messages[0]);
}

	5.	Keep the keyboard behavior as-is

Do not re-wrap the whole screen again. Keep the layout you just reverted to, and only use the small Pressable trick we already have for dismissing the keyboard.
