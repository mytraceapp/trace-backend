Do Phase 3 now, but do it surgically: one flag, one choke-point, no scattered ifs.

⸻

Phase 3 Implementation: One choke-point + one flag

Add env flag
	•	TRACE_V2_STRIP_INJECTIONS=1 (default 0)

Define the rule

If useV2 === true AND TRACE_V2_STRIP_INJECTIONS===1:
	•	Do not append: convo probe rules, T2 manifesto, doorways catalog, EI paragraphs, duplicate anti-repetition
	•	Do still append (if you want, but keep tiny): disclaimer/no-repeat (or put it in directive), one anti-repeat list (already in directive), anything required for crisis (but crisis bypasses anyway)

⸻

Step 3.1 (Low risk): Remove T2 manifesto contamination

Action: wrap the append block with:
const strip = useV2 && process.env.TRACE_V2_STRIP_INJECTIONS === "1";
if (!strip) {
  // append T2 manifesto block
}

Even better: don’t “wrap each injection” — instead, stop calling the entire legacy injection section when strip is on (next section).

Keep model routing unchanged (gpt-5.1 stays).

⸻

Step 3.2: Remove duplicate anti-repetition injection

Since V2 directive already includes the opener list, you should not append it again.

Under strip mode:
	•	do nothing (directive already contains it)

Under legacy:
	•	keep existing behavior

⸻

Step 3.3: Doorways catalog removal (V2)

Under strip mode:
	•	remove catalog injection entirely
	•	keep doorwayHint line in directive (already)

Under legacy:
	•	keep catalog for now (until legacy is retired)

⸻

Step 3.4: EI paragraphs removal (V2)

Under strip mode:
	•	replace EI paragraph injection with 1–3 bullets (only if non-neutral)

But since you already have V2 directive and traceIntent.signals.cognitive / traceBrain / attunement, you can put EI-derived bullets into selectedContext.patternBullets or a new selectedContext.signalBullets.

Minimal safe approach:
	•	don’t inject EI paragraphs at all
	•	log if EI would have injected, so you can confirm you’re not losing critical behavior

Then in the next iteration, add bullets if needed.

⸻

Step 3.5: ConversationState probe rules injection (V2)

Under strip mode:
	•	remove prompt probe rules injection
	•	keep server enforcement: violatesProbeRules() + updateStateAfterResponse() ✅

Optionally, in directive, you can include a single line like:
	•	Questions allowed: 0|1 (which you already do via allowQuestions)

That’s more reliable than prose rules.

⸻

The cleanest code change: isolate “append legacy injections” into a function

Right now your issue exists because injection code is “downstream” and appends no matter what.

Do this:
	1.	Extract all legacy appenders into:
appendLegacyPromptInjections({ systemPrompt, ...deps }) -> systemPrompt
	2.	Call it only when allowed:
const strip = useV2 && process.env.TRACE_V2_STRIP_INJECTIONS === "1";

if (!strip) {
  systemPrompt = appendLegacyPromptInjections({ systemPrompt, ...deps });
} else {
  // V2 stays pure — nothing appended here
}

That one move kills the Frankenstein problem permanently.

⸻

3.0 Guardrails (you should add these immediately)

When useV2:
	•	Log the final prompt length (chars or approximate tokens)
	•	Log whether strip is on
	•	Log which injections were skipped

Example:
if (process.env.TRACE_INTENT_LOG === "1") {
  console.log("[phase3]", {
    requestId,
    useV2,
    strip,
    promptChars: systemPrompt.length
  });
}

If you want one extra sanity check:
	•	assert that when strip===true, none of the known legacy sentinel strings are present in systemPrompt (e.g., “Premium Experience Mode”).

⸻

Rollout plan
	1.	Deploy with TRACE_V2_STRIP_INJECTIONS=0 (no behavior change)
	2.	Turn on TRACE_V2_STRIP_INJECTIONS=1 in dev/staging
	3.	In prod: start with TRACE_PROMPT_V2_PCT=10 and STRIP_INJECTIONS=1
	4.	If metrics good: raise pct gradually

Rollback is instant by flipping the env var.