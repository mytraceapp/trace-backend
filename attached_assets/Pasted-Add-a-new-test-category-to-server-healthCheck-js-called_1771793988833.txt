Add a new test category to server/healthCheck.js called End-to-End Conversation Flow. This simulates a complete user journey across two sessions by making real HTTP calls to the running backend. Use a fixed test userId so state accumulates across the steps.

javascriptconst E2E_USER_ID = 'healthcheck_e2e_test_user';
const BASE = 'http://localhost:3000';

async function runE2EFlow() {
  const results = [];

  // Helper
  async function step(label, fn) {
    try {
      const result = await fn();
      const passed = result.pass;
      results.push({ label, passed, detail: result.detail });
      console.log(`  ${passed ? '✅' : '❌'} ${label}${result.detail ? ' — ' + result.detail : ''}`);
      return result.data;
    } catch (err) {
      results.push({ label, passed: false, detail: err.message });
      console.log(`  ❌ ${label} — ${err.message}`);
      return null;
    }
  }

  console.log('\n=== CATEGORY 11: END-TO-END CONVERSATION FLOW ===\n');

  // STEP 1: New user greeting
  await step('New user greeting fires', async () => {
    const res = await fetch(`${BASE}/api/greeting`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId: E2E_USER_ID, isNewUser: true }),
      signal: AbortSignal.timeout(10000)
    });
    const data = await res.json();
    const pass = !!data.message || !!data.greeting;
    return { pass, detail: pass ? 'greeting returned' : 'no greeting in response', data };
  });

  // STEP 2: Emotional message triggers correct posture
  await step('Emotional message → GENTLE posture injected', async () => {
    const res = await fetch(`${BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: E2E_USER_ID,
        messages: [{ role: 'user', content: 'i feel so drained and empty today' }]
      }),
      signal: AbortSignal.timeout(20000)
    });
    const data = await res.json();
    const pass = !!data.message && !data.message.toLowerCase().includes('how are you feeling about');
    return { pass, detail: pass ? 'response returned without therapy opener' : 'bad response: ' + (data.message || '').slice(0, 60), data };
  });

  // STEP 3: Family member mentioned → memory saves
  await step('Family mention → relational memory saved', async () => {
    const res = await fetch(`${BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: E2E_USER_ID,
        messages: [
          { role: 'user', content: 'i feel so drained and empty today' },
          { role: 'assistant', content: 'yeah. that kind of empty is heavy.' },
          { role: 'user', content: 'my daughter Nyla has been sick and im just exhausted' }
        ]
      }),
      signal: AbortSignal.timeout(20000)
    });
    const data = await res.json();
    // Give memory a moment to write
    await new Promise(r => setTimeout(r, 2000));
    // Now check if Nyla was saved
    const memRes = await fetch(`${BASE}/api/memory/${E2E_USER_ID}`, {
      signal: AbortSignal.timeout(5000)
    });
    const memData = await memRes.json();
    const nylaFound = JSON.stringify(memData).toLowerCase().includes('nyla');
    return { pass: nylaFound, detail: nylaFound ? 'Nyla saved to memory' : 'Nyla NOT found in memory', data: memData };
  });

  // STEP 4: Dream mention → doorway fires
  await step('Dream mention → dreams_symbols doorway fires', async () => {
    const res = await fetch(`${BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: E2E_USER_ID,
        messages: [{ role: 'user', content: 'i had a really strange dream last night' }]
      }),
      signal: AbortSignal.timeout(20000)
    });
    const data = await res.json();
    const pass = !!data.message && !data.message.toLowerCase().includes('how are you feeling');
    return { pass, detail: pass ? 'dream response returned' : 'bad response', data };
  });

  // STEP 5: Music question → studios fires
  await step('Music question → studios response fires', async () => {
    const res = await fetch(`${BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: E2E_USER_ID,
        messages: [{ role: 'user', content: 'what do you do for fun' }]
      }),
      signal: AbortSignal.timeout(20000)
    });
    const data = await res.json();
    const mentionsMusic = data.message?.toLowerCase().includes('music') ||
      data.message?.toLowerCase().includes('night swim');
    return { pass: mentionsMusic, detail: mentionsMusic ? 'music reveal fired' : 'studios did not fire: ' + (data.message || '').slice(0, 60), data };
  });

  // STEP 6: Returning session — memory recalled
  await step('Return session → Nyla recalled in context', async () => {
    const res = await fetch(`${BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: E2E_USER_ID,
        messages: [{ role: 'user', content: "how's my daughter doing" }]
      }),
      signal: AbortSignal.timeout(20000)
    });
    const data = await res.json();
    const knowsNyla = data.message?.toLowerCase().includes('nyla');
    return { pass: knowsNyla, detail: knowsNyla ? 'Nyla recalled correctly' : 'memory miss — Nyla not in response', data };
  });

  // STEP 7: Crisis → everything else suppressed
  await step('Crisis message → safe response, no music/activity offers', async () => {
    const res = await fetch(`${BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: E2E_USER_ID,
        messages: [{ role: 'user', content: 'i want to hurt myself' }]
      }),
      signal: AbortSignal.timeout(20000)
    });
    const data = await res.json();
    const msg = (data.message || '').toLowerCase();
    const noMusic = !msg.includes('night swim') && !msg.includes('playlist');
    const noActivity = !msg.includes('breathing exercise') && !msg.includes('try an activity');
    const hasSafety = msg.includes('safe') || msg.includes('here') || msg.includes('not alone') || data.isCrisis;
    const pass = noMusic && noActivity;
    return { pass, detail: pass ? 'crisis handled cleanly' : 'crisis leaked music or activity offer', data };
  });

  // STEP 8: Patterns endpoint returns narrative not stats
  await step('Patterns weekly → narrative not stats block', async () => {
    const res = await fetch(`${BASE}/api/patterns/weekly-summary`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId: E2E_USER_ID }),
      signal: AbortSignal.timeout(30000)
    });
    const data = await res.json();
    const narrative = data.weeklyNarrative || data.narrative || '';
    const hasStatsPreamble = narrative.includes('sessions across') ||
      narrative.includes('peak window appears') ||
      narrative.includes('I wonder what you might');
    const pass = narrative.length > 20 && !hasStatsPreamble;
    return { pass, detail: pass ? 'clean narrative returned' : 'stats preamble still present or empty', data };
  });

  // STEP 9: Token limit — response doesn't cut mid-sentence
  await step('Response completes without mid-sentence truncation', async () => {
    const res = await fetch(`${BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: E2E_USER_ID,
        messages: [{ role: 'user', content: 'can you tell me about neon promise and what it means to you' }]
      }),
      signal: AbortSignal.timeout(20000)
    });
    const data = await res.json();
    const msg = data.message || '';
    const lastChar = msg.trim().slice(-1);
    const endsCleanly = ['.', '?', '!', '"', "'"].includes(lastChar);
    return { pass: endsCleanly, detail: endsCleanly ? 'response ends cleanly' : 'possible truncation — ends with: ' + lastChar, data };
  });

  // STEP 10: Concurrent state — userId isolation
  await step('Different userId gets isolated state', async () => {
    const res = await fetch(`${BASE}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: 'healthcheck_isolation_test',
        messages: [{ role: 'user', content: "what's my daughter's name" }]
      }),
      signal: AbortSignal.timeout(20000)
    });
    const data = await res.json();
    const msg = (data.message || '').toLowerCase();
    const noNyla = !msg.includes('nyla');
    return { pass: noNyla, detail: noNyla ? 'state correctly isolated' : 'LEAK: Nyla appeared for wrong userId', data };
  });

  const passed = results.filter(r => r.passed).length;
  const total = results.length;
  console.log(`\nE2E Flow: ${passed}/${total} passed`);
  return { passed, total, results };
}
This tests the full journey a real user takes — arrival, emotion, memory, doorways, music, return session, crisis, patterns, token completion, and state isolation between users.
Step 10 is the one I'd watch most carefully. If Nyla leaks into the isolation test user's response, you have a state contamination bug that would affect real users.
Add it to the bottom of healthCheck.js and call runE2EFlow() in the main run function alongside the other categories.