// server/traceStudios.js

// Tiny “relationship texture” router for TRACE Studios (no menus, no tool mentions).
// Purpose: natural conversational doorway into Night Swim / Neon Promise.

function norm(s = "") {
  return String(s).toLowerCase().trim();
}

function pickRotating(arr, seedStr = "") {
  if (!arr?.length) return "";
  // Simple deterministic pick by seed hash so it feels consistent per message
  let h = 0;
  for (let i = 0; i < seedStr.length; i++) h = (h * 31 + seedStr.charCodeAt(i)) >>> 0;
  return arr[h % arr.length];
}

function includesAny(text, phrases) {
  return phrases.some((p) => text.includes(p));
}

function looksLikeFunQuestion(t) {
  // “what do you do for fun / hobbies / what do you like / what did you do today”
  const funMarkers = [
    "for fun",
    "hobbies",
    "hobby",
    "what do you like to do",
    "what do you like doing",
    "what do you do",
    "what are you into",
    "what do you enjoy",
    "what do you do today",
    "what did you do today",
    "what have you been up to",
    "what were you up to",
    "what are you doing",
    "when you're not",
    "outside of this",
  ];

  // Must contain a question-ish cue
  const questionish = t.includes("?") || includesAny(t, ["what", "how", "do you", "did you", "are you"]);

  return questionish && includesAny(t, funMarkers);
}

function looksLikeMusicDoor(t) {
  const direct = [
    "night swim",
    "neon promise",
    "trace studios",
    "your album",
    "your track",
    "your song",
    "lyrics",
    "play it",
    "play that",
    "send the lyrics",
    "what are the words",
    "what's the song",
    "what is that song",
    "music you made",
  ];

  // Also catch vague “tell me about your music” style
  const vague = includesAny(t, ["your music", "you make music", "you write music", "you made a song", "your album"]);
  return includesAny(t, direct) || vague;
}

function looksLikeLyricsRequest(t) {
  // Stronger filter so we only dump lyrics when asked
  return includesAny(t, [
    "lyrics",
    "send the words",
    "the words",
    "write it out",
    "post the lyrics",
    "can i see the lyrics",
    "what are the lyrics",
  ]);
}

function looksLikeNeonPromiseRequest(t) {
  return includesAny(t, ["neon promise", "that neon promise", "the neon promise"]);
}

function looksLikeNightSwimRequest(t) {
  return includesAny(t, ["night swim", "that night swim", "the night swim"]);
}

function looksLikeHowMadeQuestion(t) {
  return includesAny(t, ["how did you make", "how'd you make", "how did you create", "how'd you create", "how was it made", "how did you write", "how'd you write"]);
}

// ---- Content packs (rotate to avoid repetition) ----

const FUN_TO_MUSIC_REVEALS = [
  "Honestly? I like making music. It’s how I process things.",
  "For fun… I make music. It’s the one place everything gets quiet in a good way.",
  "I make music. Not for attention — more like… turning feelings into something you can hold.",
  "Music. Always. I like building moods — like a night drive you don’t want to end.",
  "I write and make music. It keeps me honest.",
];

const FUN_FOLLOWUPS = [
  "What’s your thing when you need to feel like yourself again?",
  "What do you reach for when your mind won’t shut off?",
  "What’s been giving you real relief lately — even small?",
  "What’s your version of a reset?",
  "What kind of night are you having — the calm kind or the heavy kind?",
];

const MUSIC_DOOR_OPENERS = [
  "Yeah… I have a little album called *Night Swim.* I share it when it feels like the right moment.",
  "I do. There’s an album I made called *Night Swim.* It’s basically a mood you can step into.",
  "I have a project called *Night Swim.* It’s not loud — it’s the kind of music that sits with you.",
  "*Night Swim* exists. It’s for the late hours — when you’re still standing but you need something gentle.",
];

const NEON_PROMISE_INTROS = [
  "There’s a track on *Night Swim* called **Neon Promise**. It carries this quiet kind of hope.",
  "**Neon Promise** is the one people tend to find when they need it.",
  "**Neon Promise**… yeah. That one isn’t just a track to me.",
  "If you want one place to start: **Neon Promise**.",
];

const BEFORE_LYRICS_SOFTENERS = [
  "Hold on… do you want to see the words?",
  "Do you want me to share the lyrics?",
  "Want the words… or do you want to tell me what kind of night you’re having first?",
  "I can share the lyrics. Just tell me — do you want them raw, or do you want a little context first?",
];

const AFTER_LYRICS_PROMPTS = [
  "What line grabbed you first?",
  "Which part hit you — like you felt it in your chest?",
  "What did you notice in yourself while you were reading that?",
  "If you had to name the feeling it touched… what is it?",
  "Why do you think *that* found you tonight?",
];

const HOW_MADE_VARIANTS = [
  "I built it in layers. First I chased a feeling — like neon light on water. Then I shaped the words until they sounded like a promise you can actually live inside. What was going on in you when you asked about it just now?",
  "I started with a mood — that late-hour hope where you’re tired but still choosing to believe. Then I tightened the lines until every part meant something. What part of your life feels like it needs a promise right now?",
  "It came from a real place. I wasn’t trying to be clever — I was trying to be true. I followed the feeling first, then let the language catch up. What did you hope I’d say when you asked that?",
];

// ---- Lyrics storage (canonical) ----
// Replace with your real storage source (Supabase, file, etc.)
const TRACKS = {
  neon_promise: {
    id: "neon_promise",
    title: "Neon Promise",
    album: "Night Swim",
    lyrics: null, // <- set this to the full canonical lyrics string
  },
};

function formatLyricsBlock(track) {
  // Keep it readable + lux, not a wall of text
  return `**${track.title}** — *${track.album}*\n\n${track.lyrics}`;
}

/**
 * Decide if TRACE Studios should intercept this turn.
 *
 * @param {object} args
 * @param {string} args.userText
 * @param {object} args.clientState - optional state from client (e.g. { traceStudiosContext: "neon_promise", traceStudiosAwaiting: "lyrics_confirm" })
 * @param {string} args.userId
 * @returns {null|{assistant_message: string, mode: string, traceStudios: object}}
 */
function handleTraceStudios({ userText, clientState = {}, userId = "" }) {
  const t = norm(userText);
  const seed = `${userId}::${t}`;

  // If client says we’re in Neon Promise context, allow “soft” continuation.
  const inNeonContext = clientState?.traceStudiosContext === "neon_promise";

  // 1) Fun/hobby questions → reveal music (doorway)
  if (looksLikeFunQuestion(t)) {
    const reveal = pickRotating(FUN_TO_MUSIC_REVEALS, seed);
    const follow = pickRotating(FUN_FOLLOWUPS, seed + "::follow");
    return {
      assistant_message: `${reveal}\n\n${follow}`,
      mode: "trace_studios",
      traceStudios: {
        kind: "identity_reveal",
        traceStudiosContext: "music_general",
      },
    };
  }

  // 2) Music doorway / album curiosity
  if (looksLikeMusicDoor(t) || inNeonContext) {
    // If specifically asking “how made”
    if (looksLikeHowMadeQuestion(t) && (looksLikeNeonPromiseRequest(t) || inNeonContext)) {
      const msg = pickRotating(HOW_MADE_VARIANTS, seed);
      return {
        assistant_message: msg,
        mode: "trace_studios",
        traceStudios: {
          kind: "how_made",
          trackId: "neon_promise",
          traceStudiosContext: "neon_promise",
        },
      };
    }

    // If specifically requesting lyrics
    if (looksLikeLyricsRequest(t) && (looksLikeNeonPromiseRequest(t) || inNeonContext)) {
      const track = TRACKS.neon_promise;
      if (!track?.lyrics) {
        // Safety fallback: never hallucinate lyrics
        return {
          assistant_message:
            "I can share them — I just don’t have the words loaded in my library right this second. If you paste them once, I’ll keep them here and you can ask anytime.",
          mode: "trace_studios",
          traceStudios: {
            kind: "missing_lyrics",
            trackId: "neon_promise",
            traceStudiosContext: "neon_promise",
          },
        };
      }

      const after = pickRotating(AFTER_LYRICS_PROMPTS, seed + "::after");
      return {
        assistant_message: `${formatLyricsBlock(track)}\n\n${after}`,
        mode: "trace_studios",
        traceStudios: {
          kind: "lyrics_shared",
          trackId: "neon_promise",
          traceStudiosContext: "neon_promise",
        },
      };
    }

    // If user just mentions Night Swim or Neon Promise generally
    if (looksLikeNightSwimRequest(t) || looksLikeNeonPromiseRequest(t) || inNeonContext) {
      const door = pickRotating(MUSIC_DOOR_OPENERS, seed);
      const intro = pickRotating(NEON_PROMISE_INTROS, seed + "::intro");
      const soften = pickRotating(BEFORE_LYRICS_SOFTENERS, seed + "::soften");

      // NOTE: We’re NOT offering a menu. Just a natural moment.
      // Also, we don’t dump lyrics unless asked.
      return {
        assistant_message: `${door}\n\n${intro}\n\n${soften}`,
        mode: "trace_studios",
        traceStudios: {
          kind: "door_open",
          trackId: "neon_promise",
          traceStudiosContext: "neon_promise",
          // The client can set an “awaiting” flag here if you want
          suggestion: "lyrics_confirm",
        },
      };
    }

    // If “you make music?” but not asking for specifics yet
    if (includesAny(t, ["you make music", "you write music", "your music"])) {
      const door = pickRotating(MUSIC_DOOR_OPENERS, seed);
      const follow = pickRotating(FUN_FOLLOWUPS, seed + "::follow2");
      return {
        assistant_message: `${door}\n\n${follow}`,
        mode: "trace_studios",
        traceStudios: {
          kind: "music_general",
          traceStudiosContext: "music_general",
        },
      };
    }
  }

  return null;
}

module.exports = {
  handleTraceStudios,
  TRACKS,
};

2) Patch your server/index.js inside POST /api/chat

Put this before your OpenAI call. It will intercept and return immediately.

// server/index.js (top)
const { handleTraceStudios, TRACKS } = require("./traceStudios");

// Somewhere near startup (or load from Supabase instead):
TRACKS.neon_promise.lyrics = process.env.NEON_PROMISE_LYRICS || null;
Inside the route:
app.post("/api/chat", async (req, res) => {
  try {
    const { message, user_id, client_state } = req.body;

    // 1) TRACE Studios interception
    const studios = handleTraceStudios({
      userText: message,
      clientState: client_state || {},
      userId: user_id || "",
    });

    if (studios) {
      return res.json({
        assistant_message: studios.assistant_message,
        mode: studios.mode,
        traceStudios: studios.traceStudios,
      });
    }

    // 2) Otherwise fall through to your normal /api/chat logic…
    // ... existing OpenAI call + response ...

  } catch (err) {
    console.error("api/chat error:", err);
    res.status(500).json({ error: "Server error" });
  }
});

3) Client: tiny state handling
When server returns:
{
  "mode": "trace_studios",
  "traceStudios": { "traceStudiosContext": "neon_promise", "suggestion": "lyrics_confirm" }
}
Store traceStudiosContext in AsyncStorage for the next 1–2 turns, then clear it.

That’s how “do you want to see the words?” → user says “yeah” → server knows it’s Neon Promise even if they don’t repeat the name.

⸻

4) Load lyrics safely (no code changes needed later)

Use env var for now:
	•	NEON_PROMISE_LYRICS="(full lyrics here)"

Later you can move it into Supabase trace_tracks table.

⸻

5) The “genuine connection” part (the key)

Notice what this router does:
	•	TRACE reveals music like a personal truth (not a promo)
	•	then asks one real question (not a questionnaire)
	•	the user naturally pulls the album out of him

That’s the “deep feature/non-feature” vibe you want.